# LPC 代码格式化程序 PRD（产品需求文档）

## 1. 项目概览

### 1.1 项目背景
LPC Support 扩展目前提供了语法高亮、代码补全、诊断等功能，但缺少代码格式化功能。作为一个成熟的 IDE 扩展，代码格式化是提升开发体验和代码质量的重要功能。

### 1.2 项目目标
为 LPC Support VS Code 扩展添加完整的代码格式化功能，支持：
- 整个文档格式化
- 选中范围格式化  
- 保存时自动格式化
- 输入时增量格式化
- 可配置的格式化选项

### 1.3 核心价值
- **一致性**：确保团队代码风格统一
- **可读性**：提高代码可读性和维护性
- **效率**：自动化代码格式化，减少手动调整时间
- **标准化**：建立 LPC 代码格式化标准

## 2. 功能需求

### 2.1 核心功能

#### 2.1.1 文档格式化
- **完整文档格式化**：格式化整个 LPC 文件
- **选中范围格式化**：格式化用户选中的代码区域
- **快捷键支持**：支持标准的格式化快捷键（Shift+Alt+F）

#### 2.1.2 实时格式化
- **保存时格式化**：保存文件时自动格式化（可配置）
- **粘贴时格式化**：粘贴代码时自动格式化（可配置）
- **输入时格式化**：特定字符输入后触发格式化（如 `;`, `}`, `)`）

#### 2.1.3 智能缩进和对齐
- **块级缩进**：函数体、控制结构、数据结构定义的正确缩进
- **参数对齐**：长参数列表的智能换行和对齐
- **表达式格式化**：复杂表达式的换行和缩进
- **注释对齐**：保持注释的合理对齐

### 2.2 LPC 特定功能

#### 2.2.1 预处理器指令格式化
- **包含语句**：`#include` 指令的排序、分组和对齐
  - 系统包含（尖括号）优先于本地包含（引号）
  - 按路径深度和字母顺序排序
  - 支持条件包含的嵌套缩进
- **宏定义**：`#define` 的对齐和续行处理
  - 宏名和值的列对齐
  - 多行宏的反斜杠对齐
  - 函数式宏参数的格式化
- **条件编译**：`#if`、`#ifdef`、`#ifndef` 的缩进
  - 嵌套条件的递进缩进
  - `#else`、`#elif` 的对齐
  - 条件表达式的格式化

#### 2.2.2 继承和面向对象格式化
- **继承语句**：`inherit` 语句的标准化格式
  - 多重继承的垂直对齐或水平排列
  - 继承路径的标准化表示
  - 与变量声明的空行分隔
- **类作用域操作符**：`class::member` 的间距处理
- **对象实例化**：`new()` 和 `clone_object()` 的参数格式化

#### 2.2.3 数据类型和字面量格式化
- **映射字面量**：`([ key : value ])` 的格式化
  - 键值对的垂直对齐
  - 嵌套映射的缩进处理
  - 空映射的紧凑表示 `([ ])`
- **数组字面量**：`({ element1, element2 })` 的格式化
  - 长数组的自动换行
  - 元素对齐和尾随逗号处理
  - 嵌套数组的缩进
- **结构体定义和实例化**：
  - `struct` 成员变量的对齐
  - 结构体实例化的格式化
  - `->` 操作符的间距处理
- **字符串定界符**：`@DELIMITER...DELIMITER;` 的处理
  - 定界符的标准化命名
  - 内容的原样保持
  - 数组定界符 `@@DELIMITER` 的格式化
- **缓冲区字面量**：buffer 类型的十六进制表示格式化

#### 2.2.4 函数和闭包格式化
- **函数声明和定义**：
  - 修饰符的标准顺序：`[access] [special] return_type function_name`
  - `varargs` 参数的格式化：`mixed *args...`
  - 引用参数的格式化：`type ref param`
  - 默认参数的格式化：`type param : (: default_value :)`
- **函数指针和闭包**：
  - 简单闭包：`(: function_name :)` 的紧凑格式
  - 带参数闭包：`(: function_name, arg1, arg2 :)` 的换行规则
  - 表达式闭包：`(: $1 + $2 :)` 中表达式的格式化
  - 局部变量捕获：`(: $(var) :)` 的处理
- **匿名函数**：
  - `function(params) { body }` 的缩进和换行
  - 与赋值语句的对齐
- **Apply 函数**：系统回调函数的标准格式
  - `create()`, `init()`, `heart_beat()` 等的统一格式
  - 可变参数 apply 的处理

#### 2.2.5 控制流和循环结构
- **foreach 循环**：LPC 特有循环的格式化
  - `foreach (var in array)` 的标准格式
  - 双变量遍历：`foreach (key, value in mapping)`
  - 引用遍历：`foreach (ref item in array)` 的格式化
- **switch 语句扩展**：
  - 字符串 case 的格式化：`case "string":`
  - 范围 case 的格式化：`case 1..10:`, `case ..5:`, `case 10..:`
  - 混合类型 case 的对齐

#### 2.2.6 运算符和表达式格式化
- **LPC 特殊运算符**：
  - 子字符串操作：`str[n..m]`, `str[<n]`, `str[n..]` 的间距
  - 数组操作：`arr[<n]`, `arr[n..]` 的格式化
  - 数组延展：`...array` 操作符的间距
- **数组和字符串运算**：
  - 集合运算：`array1 & array2`, `array1 | array2` 的换行
  - 差集运算：`array1 - array2` 的格式化
- **类型判断函数**：
  - `functionp()`, `mappingp()`, `objectp()` 等的标准格式
- **复杂表达式**：
  - 三元运算符的换行规则
  - 逻辑运算符的返回值特性处理

### 2.3 配置功能

#### 2.3.1 缩进配置
- **缩进类型**：空格或制表符
- **缩进大小**：2, 4, 8 空格选项
- **连续缩进**：换行后的额外缩进

#### 2.3.2 括号风格
- **大括号风格**：
  - K&R 风格（同行开括号）
  - Allman 风格（新行开括号）  
  - GNU 风格（缩进开括号）
- **小括号间距**：函数调用和控制结构的括号间距

#### 2.3.3 空格和换行
- **运算符间距**：二元运算符前后的空格
- **逗号后空格**：参数列表、数组元素间的空格
- **最大行长度**：超过指定长度时自动换行
- **空行保留**：连续空行的最大保留数量

#### 2.3.4 LPC 特定配置
- **预处理器配置**：
  - 包含语句排序策略（系统/用户/混合）
  - 宏定义对齐方式（列对齐/简单对齐）
  - 条件编译缩进级别（递进/平行）
- **继承和对象配置**：
  - 继承语句排列方式（垂直/水平）
  - 类作用域操作符间距配置
  - 对象实例化风格选择
- **数据类型配置**：
  - 映射字面量格式（紧凑/展开/智能）
  - 数组字面量换行阈值（元素数量限制）
  - 结构体成员对齐方式
  - 字符串定界符命名风格
- **函数和闭包配置**：
  - 函数修饰符顺序配置
  - 闭包表达式的简化策略
  - varargs 参数的显示风格
  - 匿名函数的换行阈值
- **控制流配置**：
  - foreach 循环的变量间距
  - switch case 的对齐方式（与 switch 对齐/缩进）
  - 范围 case 的格式化风格
- **运算符和表达式配置**：
  - 数组索引操作符间距（`arr[n]` vs `arr[ n ]`）
  - 集合运算符的换行策略
  - 三元运算符的对齐方式
- **注释和文档配置**：
  - 是否格式化注释内容
  - 行内注释的对齐方式
  - 函数文档注释的格式风格

## 3. 技术需求

### 3.1 技术架构

#### 3.1.1 格式化引擎
```typescript
interface LPCFormatter {
    formatDocument(text: string, options: FormattingOptions): string;
    formatRange(text: string, range: Range, options: FormattingOptions): TextEdit[];
    formatOnType(text: string, position: Position, character: string, options: FormattingOptions): TextEdit[];
}
```

#### 3.1.2 访问者模式实现
```typescript
class FormatterVisitor extends AbstractParseTreeVisitor<FormattedText> {
    private indentLevel: number;
    private options: FormattingOptions;
    private tokenStream: CommonTokenStream;
    
    visitSourceFile(ctx: SourceFileContext): FormattedText;
    visitFunctionDef(ctx: FunctionDefContext): FormattedText;
    visitBlock(ctx: BlockContext): FormattedText;
    visitStatement(ctx: StatementContext): FormattedText;
    visitExpression(ctx: ExpressionContext): FormattedText;
}
```

#### 3.1.3 令牌处理器
```typescript
class TokenProcessor {
    preserveComments(tokens: Token[]): CommentInfo[];
    handleWhitespace(tokens: Token[], options: FormattingOptions): Token[];
    formatSpecialTokens(tokens: Token[]): Token[];
}
```

### 3.2 集成需求

#### 3.2.1 VS Code 集成
- **DocumentFormattingEditProvider**：完整文档格式化
- **DocumentRangeFormattingEditProvider**：范围格式化
- **OnTypeFormattingEditProvider**：输入时格式化
- **配置系统集成**：使用 VS Code 配置 API

#### 3.2.2 现有系统集成
- **AST 管理器集成**：复用现有的解析缓存
- **诊断系统集成**：格式化时处理解析错误
- **配置管理器集成**：统一的配置管理

#### 3.2.3 性能优化
- **增量格式化**：只格式化变更区域
- **异步处理**：大文件的非阻塞格式化
- **缓存机制**：格式化结果缓存

### 3.3 错误处理

#### 3.3.1 解析错误处理
- **部分格式化**：语法错误时格式化有效部分
- **错误恢复**：尽可能保持原始格式
- **用户提示**：清晰的错误信息和建议

#### 3.3.2 配置错误处理
- **配置验证**：格式化选项的合法性检查
- **默认值回退**：无效配置时使用默认值
- **配置修复建议**：提供配置修正建议

## 4. 用户体验需求

### 4.1 易用性需求

#### 4.1.1 直观操作
- **右键菜单**：文档格式化选项
- **命令面板**：通过命令面板访问格式化功能
- **快捷键**：标准的格式化快捷键支持
- **状态栏提示**：格式化操作的状态反馈

#### 4.1.2 配置界面
- **设置页面**：VS Code 设置页面中的格式化选项
- **预设模板**：常用格式化风格的预设
- **实时预览**：配置更改的实时预览效果

#### 4.1.3 性能体验
- **响应速度**：小于 100ms 的格式化响应时间
- **进度指示**：大文件格式化的进度显示
- **取消操作**：长时间操作的取消支持

### 4.2 功能完整性

#### 4.2.1 格式化质量
- **保持语义**：格式化不改变代码语义
- **注释保留**：正确处理和保留代码注释
- **字符串保护**：不修改字符串字面量内容
- **预处理器支持**：正确处理宏定义和条件编译

#### 4.2.2 边界情况处理
- **不完整代码**：编辑过程中的部分代码格式化
- **混合格式**：现有格式和新格式的兼容处理
- **特殊字符**：Unicode 字符和特殊符号的处理

## 5. 实现计划

### 5.1 开发阶段

#### 5.1.1 第一阶段：基础功能（2-3周）
- 实现基础的文档格式化功能
- 完成缩进和基本的语句格式化
- 集成到 VS Code 扩展中
- 基本的配置选项支持

#### 5.1.2 第二阶段：LPC 特定功能（2-3周）
- 实现 LPC 特有语法的格式化
- 完善函数和数据结构格式化
- 增加更多配置选项
- 性能优化

#### 5.1.3 第三阶段：高级功能（1-2周）
- 范围格式化和输入时格式化
- 高级配置选项
- 错误处理和用户体验优化
- 全面测试和文档

### 5.2 质量保证

#### 5.2.1 测试策略
- **单元测试**：格式化函数的单元测试
- **集成测试**：VS Code 扩展集成测试
- **回归测试**：确保现有功能不受影响
- **性能测试**：大文件和复杂代码的性能测试

#### 5.2.2 测试用例
- **语法覆盖**：所有 LPC 语法结构的测试
- **边界测试**：极端情况和错误输入的测试
- **兼容性测试**：不同 LPC 方言的兼容性
- **用户场景测试**：实际开发场景的测试

### 5.3 发布计划

#### 5.3.1 Beta 版本
- 核心格式化功能完成
- 基础配置选项支持
- 内部测试和反馈收集

#### 5.3.2 正式版本
- 所有计划功能完成
- 完整的测试覆盖
- 文档和使用指南完成
- 性能优化和错误修复

## 6. 成功指标

### 6.1 功能指标
- **格式化准确率**：>99% 的代码语义保持
- **语法覆盖率**：100% LPC 语法结构支持
- **配置选项**：至少 15 个可配置格式化选项
- **错误恢复率**：90% 的语法错误情况下部分格式化成功

### 6.2 性能指标
- **小文件响应时间**：<100ms（<1000行）
- **大文件响应时间**：<2秒（<10000行）
- **内存使用**：格式化时内存增长 <50MB
- **CPU 使用率**：格式化期间 CPU 使用率 <80%

### 6.3 用户体验指标
- **用户满意度**：通过用户反馈和 GitHub issues 跟踪
- **采用率**：扩展用户中格式化功能的使用比例
- **错误率**：用户报告的格式化错误数量
- **配置使用率**：用户自定义配置的使用情况

## 7. 风险分析

### 7.1 技术风险
- **ANTLR 解析器限制**：语法解析的局限性可能影响格式化质量
- **性能问题**：大文件格式化可能导致 VS Code 响应缓慢
- **兼容性问题**：不同 LPC 方言的兼容性挑战

### 7.2 项目风险
- **开发时间**：复杂的语法处理可能延长开发周期
- **测试覆盖**：全面的测试用例编写需要大量时间
- **用户接受度**：格式化风格的主观性可能导致用户争议

### 7.3 风险缓解措施
- **分阶段开发**：优先实现核心功能，逐步完善
- **充分测试**：建立完善的测试体系，确保质量
- **用户反馈**：及时收集和响应用户反馈
- **可配置性**：提供丰富的配置选项满足不同需求

## 8. 总结

LPC 代码格式化程序的实现将显著提升 LPC Support 扩展的完整性和用户体验。通过系统的需求分析、技术设计和实现计划，我们可以构建一个功能完善、性能优良、用户友好的代码格式化工具。

项目的成功将不仅提升现有用户的开发体验，还能吸引更多的 LPC 开发者使用这个扩展，进一步推广 LPC 语言的发展和标准化。