(* Lexical Elements *)
IDENTIFIER ::= [a-zA-Z_] [a-zA-Z0-9_]* ;
DECIMAL_LITERAL ::= [1-9] [0-9]* | '0' ;
HEX_LITERAL ::= '0' [xX] [0-9a-fA-F]+ ;
OCTAL_LITERAL ::= '0' [0-7]+ ;
INTEGER_LITERAL ::= DECIMAL_LITERAL | HEX_LITERAL | OCTAL_LITERAL ;

FLOAT_LITERAL ::= [0-9]+ '.' [0-9]+ ([eE] [+-]? [0-9]+)? |
                  '.' [0-9]+ ([eE] [+-]? [0-9]+)? |
                  [0-9]+ [eE] [+-]? [0-9]+ ;

STRING_LITERAL ::= '"' ( ~('"' | '\\') | ESCAPE_SEQUENCE )* '"' ;
ESCAPE_SEQUENCE ::= '\\' (["\\rntbf] | [0-7]{1,3} | 'x' [0-9a-fA-F]{2}) ;

LPAREN ::= '(' ;
RPAREN ::= ')' ;
LBRACE ::= '{' ;
RBRACE ::= '}' ;
LBRACKET ::= '[' ;
RBRACKET ::= ']' ;
SEMICOLON ::= ';' ;
COMMA ::= ',' ;
COLON ::= ':' ;
ARROW ::= '->' ;
LAMBDA_ARROW ::= '=>' ; (* Or '->' if overloaded, for closure parameter lists *)


LINE_COMMENT ::= '//' ~[\r\n]* ;
BLOCK_COMMENT ::= '/*' ( BLOCK_COMMENT | ~'*/' )* '*/' ; (* Naive, non-greedy not well handled in simple EBNF *)

(* Basic Program Structure *)
program ::= (preprocessor_directive | declaration | function_definition | class_definition)* ;

(* Preprocessor Directives *)
preprocessor_directive ::= include_directive | define_directive | ifdef_directive | ifndef_directive | else_directive | endif_directive | undef_directive | pragma_directive ;

include_directive ::= '#' 'include' (STRING_LITERAL | ANGLE_BRACKET_STRING) ;
ANGLE_BRACKET_STRING ::= '<' (~['>'])+ '>' ;

define_directive ::= '#' 'define' IDENTIFIER (LPAREN IDENTIFIER_LIST? RPAREN)? (preprocessor_token_sequence)? ;
IDENTIFIER_LIST ::= IDENTIFIER (COMMA IDENTIFIER)* ;
preprocessor_token_sequence ::= (PREPROCESSOR_TOKEN)* ;
PREPROCESSOR_TOKEN ::= ~(NEWLINE_TOKEN) ; (* Placeholder: any lexical token except newline *)
NEWLINE_TOKEN ::= [\r\n]+ ; (* Placeholder *)


ifdef_directive ::= '#' 'ifdef' IDENTIFIER ;
ifndef_directive ::= '#' 'ifndef' IDENTIFIER ;
else_directive ::= '#' 'else' ;
endif_directive ::= '#' 'endif' ;
undef_directive ::= '#' 'undef' IDENTIFIER ;
pragma_directive ::= '#' 'pragma' preprocessor_token_sequence ;


(* Declarations *)
declaration ::= type_modifier* type_specifier variable_declarator_list SEMICOLON ;
variable_declarator_list ::= variable_declarator (COMMA variable_declarator)* ;
variable_declarator ::= IDENTIFIER (array_indices)? (('=' expression) | ('=' initializer_list))? ;
array_indices ::= LBRACKET (expression | '')? RBRACKET (array_indices)? ;
initializer_list ::= LBRACE ('{' (expression (COMMA expression)* COMMA?)? '}') RBRACE ;


(* Type Specifiers *)
type_specifier ::= base_type_specifier (array_specifier)? ;
base_type_specifier ::= 'void' | 'int' | 'string' | 'object' | 'float' | 'mixed' | 'status' | 'buffer' | 'mapping' | 'function' | class_identifier ;
array_specifier ::= '*' ;
class_identifier ::= IDENTIFIER ;

type_modifier ::= 'static' | 'nomask' | 'private' | 'public' | 'varargs' | 'nosave' ; (* Added 'nosave' *)


(* Expressions *)
expression ::= assignment_expression ;

assignment_expression ::= conditional_expression (assignment_operator assignment_expression)? ;
assignment_operator ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' ;

conditional_expression ::= logical_or_expression ('?' expression COLON conditional_expression)? ;

logical_or_expression ::= logical_and_expression ('||' logical_and_expression)* ;
logical_and_expression ::= bitwise_or_expression ('&&' bitwise_or_expression)* ;
bitwise_or_expression ::= bitwise_xor_expression ('|' bitwise_xor_expression)* ;
bitwise_xor_expression ::= bitwise_and_expression ('^' bitwise_and_expression)* ;
bitwise_and_expression ::= equality_expression ('&' equality_expression)* ;

equality_expression ::= relational_expression (('==' | '!=') relational_expression)* ;
relational_expression ::= shift_expression (('<' | '>' | '<=' | '>=') shift_expression)* ;
shift_expression ::= additive_expression (('<<' | '>>') additive_expression)* ;
additive_expression ::= multiplicative_expression (('+' | '-') multiplicative_expression)* ;
multiplicative_expression ::= cast_expression (('*' | '/' | '%') cast_expression)* ;

cast_expression ::= (LPAREN type_specifier RPAREN cast_expression) | unary_expression ;

unary_expression ::= (('!' | '~' | '-' | '++' | '--') unary_expression) | postfix_expression ;

postfix_expression ::= primary_expression (postfix_operator | member_access | function_call | array_access | range_access)* ;
postfix_operator ::= '++' | '--' ;
member_access ::= ARROW IDENTIFIER ;
function_call ::= LPAREN argument_expression_list? RPAREN ;
argument_expression_list ::= assignment_expression (COMMA assignment_expression)* ;
array_access ::= LBRACKET expression RBRACKET ;
range_access ::= LBRACKET expression? '..' expression? RBRACKET ;


primary_expression ::= IDENTIFIER | constant | LPAREN expression RPAREN | array_literal | mapping_literal | closure_expression | function_pointer_literal | class_constructor_call ;

constant ::= INTEGER_LITERAL | FLOAT_LITERAL | STRING_LITERAL ;

array_literal ::= LBRACE ('{' (argument_expression_list | (expression (COMMA expression)* COMMA?))? '}') RBRACE ;
mapping_literal ::= LBRACE ('[' (mapping_element (COMMA mapping_element)* COMMA?)? ']') RBRACE ;
mapping_element ::= expression COLON expression ;

(* Closure Expressions - Simplified. LPC's functional syntax is extensive. *)
closure_expression ::= '(:' ( closure_args_and_body | closure_body_only | expression_closure | object_function_closure ) ':)' ;
closure_args_and_body ::= parameter_list (ARROW | LAMBDA_ARROW) statement* ; (* e.g. (: int x -> write(x) :) *)
closure_body_only ::= statement+ ; (* e.g. (: write("hello") :) *)
expression_closure ::= expression ; (* e.g. (: $1 + $2 :) or (: this_object()->foo() :) *)
object_function_closure ::= expression COMMA (STRING_LITERAL | IDENTIFIER) (COMMA array_literal)? ; (* e.g. (: ob, "func" :) or (: ob, "func", ({ arg1 }) :) *)
(* Note: This is a high-level abstraction. True LPC closure parsing needs to differentiate
   local functions `(: my_func :)`, efuns `(: an_efun :)`, simul_efuns,
   call_others `(: obj, "method" :)`, `(: obj, ({"method", arg1}) :)`,
   and expression functionals `(: $1 + $N :)`, `(: some_expr() :)`.
   The `statement*` in `closure_args_and_body` allows a sequence of statements.
*)

function_pointer_literal ::= '#' '\'' IDENTIFIER (* Local function *)
                         | expression ARROW '#' '\'' IDENTIFIER ; (* Function in another object *)


class_constructor_call ::= 'new' LPAREN 'class' class_identifier (COMMA named_argument_list)? RPAREN ;
named_argument_list ::= named_argument (COMMA named_argument)* ;
named_argument ::= IDENTIFIER COLON expression ;


(* Function Definition *)
function_definition ::= type_modifier* type_specifier IDENTIFIER LPAREN parameter_list? RPAREN compound_statement ;
parameter_list ::= parameter_declaration (COMMA parameter_declaration)* (COMMA '...')? ; (* Varargs confirmed *)
parameter_declaration ::= type_specifier IDENTIFIER (array_specifier)? ;

compound_statement ::= LBRACE (declaration | statement)* RBRACE ;


(* Statements *)
statement ::= expression_statement | compound_statement | selection_statement | iteration_statement | jump_statement | inherit_statement | try_catch_statement ;

expression_statement ::= expression? SEMICOLON ;

selection_statement ::= if_statement | switch_statement ;
if_statement ::= 'if' LPAREN expression RPAREN statement ('else' statement)? ;
switch_statement ::= 'switch' LPAREN expression RPAREN LBRACE switch_case* (default_case)? RBRACE ;
switch_case ::= 'case' (expression | STRING_LITERAL) COLON statement* ;
default_case ::= 'default' COLON statement* ;

iteration_statement ::= while_statement | for_statement | do_while_statement | foreach_statement ;
while_statement ::= 'while' LPAREN expression RPAREN statement ;
do_while_statement ::= 'do' statement 'while' LPAREN expression RPAREN SEMICOLON ;
for_statement ::= 'for' LPAREN expression_statement expression_statement expression? RPAREN statement ;
foreach_statement ::= 'foreach' LPAREN type_specifier? IDENTIFIER (COMMA type_specifier? IDENTIFIER)? 'in' expression RPAREN statement ;


jump_statement ::= 'break' SEMICOLON | 'continue' SEMICOLON | 'return' expression? SEMICOLON ;

inherit_statement ::= 'inherit' type_modifier? STRING_LITERAL SEMICOLON ;

try_catch_statement ::= 'try' compound_statement 'catch' LPAREN IDENTIFIER RPAREN compound_statement ;


(* Class Definition *)
class_definition ::= 'class' IDENTIFIER ( 'extends' class_identifier )? LBRACE (declaration | function_definition)* RBRACE SEMICOLON? ;
