// 综合语法测试用例
// 本文件测试所有新增语法特性的综合使用

// 综合测试：结合所有新特性
class SyntaxTestSuite {
    // 使用二进制字面量定义位掩码
    private int FLAG_ACTIVE = 0b0001;
    private int FLAG_VISIBLE = 0b0010;
    private int FLAG_EDITABLE = 0b0100;
    private int FLAG_DELETABLE = 0b1000;

    // 配置数据使用数组定界符
    private mapping default_config =
@@CONFIG
{
    "system": {
        "max_users": 1000,
        "timeout": 300,
        "flags": 0b1111_1111
    },
    "features": {
        "logging": true,
        "caching": false,
        "monitoring": true
    }
}
CONFIG;

    // 测试所有新特性的组合使用
    mixed comprehensive_test(mixed* input_data, int mode) {
        // 使用右索引获取最后几个元素
        mixed* recent_items = input_data[<5..];

        // 使用二进制字面量进行位操作
        int permission_flags = 0b1010_0101;

        switch(mode) {
            // 使用范围匹配
            case 0..10:
                return process_low_mode(recent_items, permission_flags);

            case 11..50:
                return process_medium_mode(...recent_items);

            case 51..:
                return process_high_mode(recent_items[<3..], permission_flags & 0b1111_0000);

            case ..(-1):
                return "Error: Invalid mode";

            default:
                return "Unknown mode";
        }
    }

    // 使用函数指针和延展语法的复杂处理
    mixed process_with_closures(mixed* data, string operation) {
        // 使用增强的函数指针语法
        string filter_property = "active";
        function filter_fn = (: $1->query($(filter_property)) :);

        // 动态操作选择
        function operation_fn;

        switch(operation) {
            case "sum":
                operation_fn = (: $1 + $2 :);
                break;

            case "multiply":
                operation_fn = (: $1 * $2 :);
                break;

            case "concat":
                operation_fn = (: sprintf("%s%s", $1, $2) :);
                break;

            default:
                operation_fn = (: $1 :);
        }

        // 过滤和处理数据
        mixed* filtered = filter(data, filter_fn);

        // 使用延展语法传递参数
        if(sizeof(filtered) > 0) {
            return reduce_with_operation(operation_fn, ...filtered);
        }

        return 0;
    }

    // 复杂的数组操作示例
    mixed* advanced_array_operations() {
        // 使用各种索引方式
        mixed* base_array = ({
            0b0001, 0b0010, 0b0100, 0b1000,    // 二进制数据
            "first", "middle", "last",          // 字符串数据
            3.14, 2.71, 1.41                   // 浮点数据
        });

        // 右索引操作
        mixed last_three = base_array[<3..];        // 最后三个
        mixed middle_section = base_array[2..<2];   // 中间部分
        mixed first_and_last = ({
            base_array[0],      // 第一个
            ...base_array[<2..<1]   // 最后两个（使用延展）
        });

        // 复杂的数据结构
        mapping result_data =
@@RESULT_DATA
{
    "original_size": sizeof(base_array),
    "last_three": last_three,
    "middle_section": middle_section,
    "binary_flags": {
        "active": 0b0001,
        "visible": 0b0010,
        "combined": 0b0011
    },
    "processing_log": [
        "Step 1: Array indexing completed",
        "Step 2: Data extraction successful",
        "Step 3: Result compilation finished"
    ]
}
RESULT_DATA;

        return ({ first_and_last, result_data });
    }

    // 高级switch语句测试
    string advanced_switch_logic(int score, int category) {
        string base_grade;
        string modifier;

        // 主要分级
        switch(score) {
            case 95..:
                base_grade = "A+";
                break;

            case 90..94:
                base_grade = "A";
                break;

            case 85..89:
                base_grade = "B+";
                break;

            case 80..84:
                base_grade = "B";
                break;

            case 70..79:
                base_grade = "C";
                break;

            case 60..69:
                base_grade = "D";
                break;

            case ..59:
                base_grade = "F";
                break;
        }

        // 类别修饰符
        switch(category & 0b1111) {  // 使用二进制掩码
            case 0b0001..0b0011:
                modifier = " (Basic)";
                break;

            case 0b0100..0b0111:
                modifier = " (Advanced)";
                break;

            case 0b1000..:
                modifier = " (Expert)";
                break;

            default:
                modifier = "";
        }

        return base_grade + modifier;
    }

    // 使用所有特性的数据处理管道
    mixed data_processing_pipeline(mixed* raw_data, mapping options) {
        // 第一阶段：数据清理
        function cleaner = (: stringp($1) ? trim($1) : $1 :);
        mixed* cleaned = map(raw_data, cleaner);

        // 第二阶段：根据选项过滤
        string filter_mode = options["filter_mode"];
        function filter_func;

        switch(filter_mode) {
            case "numeric":
                filter_func = (: intp($1) || floatp($1) :);
                break;

            case "string":
                filter_func = (: stringp($1) && strlen($1) > 0 :);
                break;

            case "positive":
                filter_func = (: (intp($1) || floatp($1)) && $1 > 0 :);
                break;

            default:
                filter_func = (: 1 :);  // 接受所有
        }

        mixed* filtered = filter(cleaned, filter_func);

        // 第三阶段：获取处理范围
        int start_index = options["start_from"] || 0;
        int end_count = options["take_last"] || 0;

        mixed* processing_range;

        if(end_count > 0) {
            // 使用右索引获取最后N个
            processing_range = filtered[<end_count..];
        } else {
            // 从指定位置开始
            processing_range = filtered[start_index..];
        }

        // 第四阶段：应用变换
        string transform_type = options["transform"];
        function transformer;

        switch(transform_type) {
            case "double":
                transformer = (: intp($1) ? $1 * 2 : $1 :);
                break;

            case "square":
                transformer = (: intp($1) ? $1 * $1 : $1 :);
                break;

            case "binary_string":
                transformer = (: intp($1) ? sprintf("0b%b", $1) : $1 :);
                break;

            default:
                transformer = (: $1 :);
        }

        mixed* transformed = map(processing_range, transformer);

        // 构建结果报告
        mapping report =
@@PIPELINE_REPORT
{
    "input_count": sizeof(raw_data),
    "after_cleaning": sizeof(cleaned),
    "after_filtering": sizeof(filtered),
    "processing_range_size": sizeof(processing_range),
    "final_count": sizeof(transformed),
    "options_used": options,
    "sample_results": transformed[<3..]  // 最后3个结果作为样本
}
PIPELINE_REPORT;

        return ({ transformed, report });
    }
}

// 全局函数测试新特性
void global_syntax_tests() {
    SyntaxTestSuite suite = new SyntaxTestSuite();

    // 测试数据
    mixed* test_data = ({
        1, 2, 3, "test", 4.5, "hello", 0b1010, "world", 99
    });

    // 综合测试
    mixed result1 = suite->comprehensive_test(test_data, 25);
    mixed result2 = suite->process_with_closures(test_data, "sum");
    mixed result3 = suite->advanced_array_operations();

    // 数据处理管道测试
    mapping pipeline_options = ([
        "filter_mode": "numeric",
        "take_last": 5,
        "transform": "binary_string"
    ]);

    mixed pipeline_result = suite->data_processing_pipeline(test_data, pipeline_options);

    // 输出结果
    printf("Comprehensive test result: %O\n", result1);
    printf("Closure processing result: %O\n", result2);
    printf("Array operations result: %O\n", result3);
    printf("Pipeline result: %O\n", pipeline_result);
}